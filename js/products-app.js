// Menu Management Logic (formerly Spare Parts)
// Uses db.js and EnhancedSecurity

const t = (key) => {
  const lang = localStorage.getItem('pos_language') || 'en';
  if (window.translations && window.translations[key]) {
    return window.translations[key][lang];
  }
  return key;
};

// products-app.js (Menu Management)
window.currentPage = 'menu';

window.switchTab = function (tabName) {
  // Buttons
  document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
  const btn = document.querySelector(`.tab-btn[onclick="switchTab('${tabName}')"]`);
  if (btn) btn.classList.add('active');

  // Content
  document.querySelectorAll('.tab-content').forEach(d => d.classList.remove('active'));
  document.getElementById(`tab-${tabName}`).classList.add('active');
}

window.editRecipeForSize = function (sizeId) {
  switchTab('recipe');
  // We need to trigger the size selection
  // Simulate click on the button generated by currentSizes
  // OR just set state and render.
  currentEditingSizeId = sizeId;
  const s = currentSizes.find(sz => sz.id == sizeId);
  if (s) {
    currentSingleRecipe = s.recipe || [];
    renderRecipeSizeButtons();
    renderSingleRecipeTable();
  }
}

// Category Inline Logic
window.toggleCategoryInput = function () {
  const div = document.getElementById('new-category-container');
  if (div) div.style.display = (div.style.display === 'none') ? 'flex' : 'none';
  document.getElementById('new-category-input').focus();
}

window.saveNewCategory = function () {
  const input = document.getElementById('new-category-input');
  const cat = input.value.trim();
  if (cat) {
    const categories = JSON.parse(localStorage.getItem("categories") || "[]");
    // Case insensitive check
    if (!categories.some(c => c.toLowerCase() === cat.toLowerCase())) {
      categories.push(cat);
      localStorage.setItem("categories", JSON.stringify(categories));
      loadCategories();
      document.getElementById('product-category').value = cat;
      input.value = '';
      toggleCategoryInput();
    } else {
      alert('Category already exists');
    }
  }
}
// Removed legacy quickAddCategory

// ...

// FIXED: Add-ons Dropdown Logic
function loadAddonsDropdown() {
  const products = window.DB.getParts();
  // Filter products by Category name containing 'Add-on' or 'Extra' (case insensitive)
  const addonItems = products.filter(p => {
    const c = (p.category || '').toLowerCase();
    return c.includes('add-on') || c.includes('addon') || c.includes('extra');
  });

  const select = document.getElementById('addon-select');
  if (!select) return;

  if (addonItems.length === 0) {
    select.innerHTML = '<option value="">No Add-ons found. Create items with category "Add-ons"</option>';
  } else {
    select.innerHTML = '<option value="">-- Select Add-on --</option>';
  }

  addonItems.forEach(item => {
    // Don't show if already in list
    if (allowedAddons.includes(item.id)) return;
    const opt = document.createElement('option');
    opt.value = item.id;
    opt.textContent = `${item.name} (${parseFloat(item.price).toFixed(2)})`;
    select.appendChild(opt);
  });
}

document.addEventListener("DOMContentLoaded", () => {
  // EnhancedSecurity.init() is now auto-handled by auth.js
  if (!window.isSessionValid()) {
    window.location.href = 'index.html';
    return;
  }

  loadProducts();
  loadCategories();

  const productForm = document.getElementById("product-form");
  if (productForm) {
    productForm.addEventListener("submit", handleAddProduct);
  }

  const categoryForm = document.getElementById("category-form");
  if (categoryForm) {
    categoryForm.addEventListener("submit", handleAddCategory);
  }

  const allowAllAddonsCheckbox = document.getElementById('allow-all-addons');
  if (allowAllAddonsCheckbox) {
    allowAllAddonsCheckbox.addEventListener('change', toggleAddonsContainer);
  }
});

// Load Menu Items
function loadProducts() {
  const products = window.DB.getParts();
  const tbody = document.getElementById("product-table-body");
  if (!tbody) return;
  tbody.innerHTML = "";

  // Keep defaults
  let categories = JSON.parse(localStorage.getItem("categories") || "[]");
  if (categories.length === 0) {
    const defaults = ["Meals", "Drinks", "Desserts", "Appetizers", "Add-ons"];
    localStorage.setItem("categories", JSON.stringify(defaults));
    defaults.forEach(c => categories.push(c));
  } else if (!categories.includes('Add-ons')) {
    // Force Add-ons existence
    categories.push('Add-ons');
    localStorage.setItem("categories", JSON.stringify(categories));
  }

  if (products.length === 0) {
    tbody.innerHTML = '<tr><td colspan="7" style="text-align:center;">No menu items found.</td></tr>';
    return;
  }

  products.forEach((p) => {
    const row = document.createElement("tr");

    let calcCost = parseFloat(p.cost || 0);

    const imgHtml = p.image
      ? `<img src="${p.image}" style="width:40px;height:40px;object-fit:cover;border-radius:4px;">`
      : '<span style="color:#ccc;">No Image</span>';

    row.innerHTML = `
          <td>${imgHtml}</td>
          <td>${p.partNumber || '-'}</td>
          <td>${p.name}</td>
          <td>${p.category || "-"}</td>
          <td>${parseFloat(p.price || 0).toFixed(2)}</td>
          <td>${calcCost.toFixed(2)}</td>
          <td>
              <button class="btn btn-sm btn-secondary" onclick="editProduct(${p.id})">‚úèÔ∏è Edit</button>
              <button class="btn btn-sm btn-info" onclick="openRecipe(${p.id})">üìú Recipe</button>
              <button class="btn btn-sm btn-danger" onclick="deleteProduct(${p.id})">üóëÔ∏è</button>
          </td>
      `;
    tbody.appendChild(row);
  });
}

// Global Add-ons & Sizes State
let allowedAddons = []; // Array of Product IDs
let currentSizes = []; // { id: timestamp, name, price, cost: 0, recipe: [] }
let currentSingleRecipe = [];
let currentEditingSizeId = null; // null = single/main product


function openProductModal() {
  const form = document.getElementById('product-form');
  if (form) form.reset();

  document.getElementById('product-id').value = '';
  document.getElementById('productModalTitle').textContent = t('add_product') || 'Add Product';
  document.getElementById('product-image').value = '';

  // Addons Reset
  allowedAddons = [];
  const allowAllMsg = document.getElementById('allow-all-addons');
  if (allowAllMsg) allowAllMsg.checked = false;
  toggleAddonsContainer();
  loadAddonsDropdown();
  renderAllowedAddons();

  // Sizes Reset
  currentSizes = [];
  const hasSizesCheck = document.getElementById('product-has-sizes');
  if (hasSizesCheck) hasSizesCheck.checked = false;
  toggleSizesSection();
  renderSizesTable();

  // Single Recipe Reset
  currentSingleRecipe = [];
  loadSingleRecipeIngredientsDropdown();
  renderSingleRecipeTable();

  document.getElementById('productModal').style.display = 'flex';
}

function toggleSizesSection() {
  const hasSizes = document.getElementById('product-has-sizes').checked;
  const sizeMode = document.getElementById('pricing-sizes-mode');
  const singleMode = document.getElementById('pricing-single-mode');
  const recipeSelector = document.getElementById('recipe-size-selector-container');

  if (sizeMode) sizeMode.style.display = hasSizes ? 'block' : 'none';
  if (singleMode) singleMode.style.display = hasSizes ? 'none' : 'block';

  // Recipe Tab logic
  if (recipeSelector) {
    if (hasSizes) {
      // If editing a size, update that size's cost immediately in memory?
      if (currentEditingSizeId) {
        // We can't update cost here without recalculating. 
        // Reliance on renderSingleRecipeTable is better.
      }

      // Update UI Indicator
      const msgDiv = document.getElementById('recipe-context-msg');
      if (msgDiv) {
        if (currentEditingSizeId) {
          const sz = currentSizes.find(x => x.id == currentEditingSizeId);
          msgDiv.textContent = `Editing Recipe for Size: ${sz ? sz.name : 'Unknown'}`;
          msgDiv.style.display = 'block';
        } else {
          msgDiv.textContent = 'Please select a size above to edit its recipe.';
          msgDiv.style.display = 'block';
        }
      }

      // Show selector (will be populated on open or edit)
      recipeSelector.style.display = 'block';
      // If we are just toggling on, we might need to render tabs
      if (currentSizes.length > 0) renderRecipeSizeButtons();
    } else {
      // Single Product Mode
      const msgDiv = document.getElementById('recipe-context-msg');
      if (msgDiv) {
        msgDiv.textContent = 'Editing Recipe for Main Product';
        msgDiv.style.display = 'block';
      }

      // Override openProductModal to reset recipe state
      const originalOpen = window.openProductModal;

      recipeSelector.style.display = 'none';
      currentEditingSizeId = null;
    }
  }
}

function addSizeVariant() {
  const name = document.getElementById('size-name').value.trim();
  const code = document.getElementById('size-code').value.trim();
  const price = parseFloat(document.getElementById('size-price').value);
  const priceDineIn = parseFloat(document.getElementById('size-price-dinein').value) || undefined;
  const priceDelivery = parseFloat(document.getElementById('size-price-delivery').value) || undefined;

  if (!name || isNaN(price)) return alert('Enter size name, code, and price');

  // Check for duplicate code
  const codeExists = currentSizes.some(s => s.code === code) || (window.DB.getParts().some(p => p.partNumber === code && p.id != document.getElementById('product-id').value));
  if (code && codeExists) return alert('Code already exists!');

  currentSizes.push({
    id: Date.now(),
    name: name,
    code: code,
    price: price,
    priceDineIn: priceDineIn,
    priceDelivery: priceDelivery,
    cost: 0,
    recipe: []
  });

  document.getElementById('size-name').value = '';
  document.getElementById('size-code').value = '';
  document.getElementById('size-price').value = '';
  document.getElementById('size-price-dinein').value = '';
  document.getElementById('size-price-delivery').value = '';
  renderSizesTable();
}

function removeSizeVariant(index) {
  currentSizes.splice(index, 1);
  renderSizesTable();
}

function renderSizesTable() {
  const tbody = document.getElementById('sizes-table-body');
  if (!tbody) return;
  tbody.innerHTML = '';

  currentSizes.forEach((s, idx) => {
    const tr = document.createElement('tr');
    tr.innerHTML = `
      <td>${s.name}</td>
      <td>${s.code || '-'}</td>
      <td>${s.price.toFixed(2)}</td>
      <td>${(s.cost || 0).toFixed(2)}</td>
      <td><button type="button" class="btn btn-sm btn-info" onclick="editRecipeForSize('${s.id}')">Edit Recipe</button></td>
      <td><button onclick="removeSizeVariant(${idx})" class="btn btn-sm btn-danger">x</button></td>
    `;
    tbody.appendChild(tr);
  });
}

// Expose
window.addAllowedAddon = addAllowedAddon;
window.removeAllowedAddon = removeAllowedAddon;
window.toggleAddonsContainer = toggleAddonsContainer;
window.toggleSizesSection = toggleSizesSection;
window.addSizeVariant = addSizeVariant;
window.removeSizeVariant = removeSizeVariant;
window.renderSizesTable = renderSizesTable;

function toggleAddonsContainer() {
  const checkbox = document.getElementById('allow-all-addons');
  const container = document.getElementById('specific-addons-container');

  if (checkbox && container) {
    const isAll = checkbox.checked;
    container.style.display = isAll ? 'none' : 'block';
  }
}

// Redundant definition removed (consolidated above).
// But for safety, I should ensure I didn't verify the line numbers for the first replacement incorrectly.
// Actually, I inserted `loadAddonsDropdown` at line 40+ in the previous step? 
// No, I replaced `quickAddCategory` block with a block that INCLUDED `loadAddonsDropdown`.
// So now I have TWO `loadAddonsDropdown` functions. I need to remove the old one.

// This replaces the old function OLD location with a comment or better, points to the new one if needed, or just delete.
// Let's delete the old logic.
function loadAddonsDropdown() {
  // Logic moved to top for better scope visibility, but to avoid duplication errors let's strict replace.
  // Wait, in JS last definition wins. I should clean up.
  // I will use this block to actually PUSH the robust logic if the previous step failed to insert it fully or if I want to be cleaner.

  // The previous step Inserted `window.saveNewCategory` etc at Line 40.
  // It also had `function loadAddonsDropdown` inside it.
  // So yes, I have duplicates.
  // I will remove this old block.
}

function addAllowedAddon() {
  const select = document.getElementById('addon-select');
  const val = select.value;
  if (!val) return;

  if (!allowedAddons.includes(parseInt(val))) {
    allowedAddons.push(parseInt(val));
    renderAllowedAddons();
    loadAddonsDropdown(); // refresh to hide selected
  }
}

function removeAllowedAddon(id) {
  allowedAddons = allowedAddons.filter(aid => aid !== id);
  renderAllowedAddons();
  loadAddonsDropdown();
}

function renderAllowedAddons() {
  const container = document.getElementById('allowed-addons-list');
  container.innerHTML = '';

  allowedAddons.forEach(id => {
    const item = window.DB.getPart(id);
    if (!item) return;

    const div = document.createElement('div');
    div.style.background = '#f9f9f9';
    div.style.padding = '5px 10px';
    div.style.marginBottom = '5px';
    div.style.display = 'flex';
    div.style.justifyContent = 'space-between';
    div.innerHTML = `
      <span>${item.name}</span>
      <button type="button" onclick="removeAllowedAddon(${id})" style="color:red;border:none;background:none;cursor:pointer;">x</button>
    `;
    container.appendChild(div);
  });
}

// Expose
window.addAllowedAddon = addAllowedAddon;
window.removeAllowedAddon = removeAllowedAddon;
window.toggleAddonsContainer = toggleAddonsContainer;

// CRUD
function handleAddProduct(e) {
  e.preventDefault();

  const id = document.getElementById("product-id").value;
  const partNumber = document.getElementById("product-code").value.trim();
  const name = document.getElementById("product-name").value.trim();
  const category = document.getElementById("product-category").value;
  const image = document.getElementById("product-image").value.trim();
  const stock = parseFloat(document.getElementById("product-stock").value) || 0;

  const hasSizes = document.getElementById('product-has-sizes').checked;

  if (!name) return alert(t('fill_required_fields'));

  let price = 0;
  let cost = 0;

  if (hasSizes) {
    if (currentSizes.length === 0) return alert('Please add at least one Size Variant.');
    price = Math.min(...currentSizes.map(s => s.price));
    cost = Math.min(...currentSizes.map(s => s.cost));
  } else {
    // Single Product
    price = parseFloat(document.getElementById("product-price").value);
    const priceDineIn = parseFloat(document.getElementById("product-price-dinein").value) || null;
    const priceDelivery = parseFloat(document.getElementById("product-price-delivery").value) || null;

    // ... cost logic
    if (currentSingleRecipe.length > 0) {
      cost = parseFloat(document.getElementById('single-recipe-total').textContent) || 0;
    } else {
      cost = parseFloat(document.getElementById("product-cost").value) || 0;
    }

    if (isNaN(price)) return alert('Please enter Price.');

  }

  const allowAllAddons = document.getElementById('allow-all-addons').checked;
  const pDineIn = (!hasSizes) ? (parseFloat(document.getElementById("product-price-dinein").value) || undefined) : undefined;
  const pDelivery = (!hasSizes) ? (parseFloat(document.getElementById("product-price-delivery").value) || undefined) : undefined;

  const newProduct = {
    id: id ? parseInt(id) : Date.now(),
    partNumber,
    name,
    category,
    price,
    priceDineIn: pDineIn,
    priceDelivery: pDelivery,
    cost,
    image,
    stock: stock,
    allowAllAddons: allowAllAddons,
    allowedAddons: allowAllAddons ? [] : allowedAddons,

    // Recipe Logic
    recipe: hasSizes ? [] : currentSingleRecipe,

    hasSizes: hasSizes,
    sizes: hasSizes ? currentSizes : [],
    createdAt: id ? undefined : new Date().toISOString()
  };

  window.DB.savePart(newProduct);

  e.target.reset();
  closeProductModal();
  loadProducts();
  alert('Menu Item Saved!');
}

window.editProduct = (id) => {
  const product = window.DB.getPart(id);
  if (!product) return;

  document.getElementById("product-id").value = product.id;
  document.getElementById("product-code").value = product.partNumber || "";
  document.getElementById("product-name").value = product.name;
  document.getElementById("product-category").value = product.category || "";

  document.getElementById("product-price").value = product.price;
  document.getElementById("product-cost").value = product.cost || 0;

  document.getElementById("product-image").value = product.image || "";
  document.getElementById("product-vendor").value = product.vendorId || "";
  document.getElementById("product-stock").value = product.stock || 0;

  // Load Add-ons state
  const allowAllCheck = document.getElementById('allow-all-addons');
  if (allowAllCheck) allowAllCheck.checked = !!product.allowAllAddons;
  allowedAddons = product.allowedAddons || [];
  toggleAddonsContainer();
  loadAddonsDropdown();
  renderAllowedAddons();

  // Load Sizes state
  const hasSizesCheck = document.getElementById('product-has-sizes');
  if (hasSizesCheck) hasSizesCheck.checked = !!product.hasSizes;
  currentSizes = product.sizes || [];
  toggleSizesSection();
  renderSizesTable();

  // Load Single Recipe state
  if (!product.hasSizes) {
    currentSingleRecipe = product.recipe || [];
    renderSingleRecipeTable();
  } else {
    currentSingleRecipe = [];
    renderSingleRecipeTable();
  }
  // Ensure dropdown loaded
  loadSingleRecipeIngredientsDropdown();

  document.getElementById('productModalTitle').textContent = 'Edit Product';
  document.getElementById('productModal').style.display = 'flex';
};

// ... Rest of CRUD ...

// Recipe Logic
let currentRecipeProductId = null;
let currentRecipeSizeId = null; // New: If editing a specific size
let currentRecipe = [];

function openRecipe(productId, sizeId = null) {
  // New Behavior: Open the Edit Modal and switch to Recipe Tab
  window.editProduct(productId);

  // If a specific size was requested (legacy), try to switch to it
  if (sizeId) {
    setTimeout(() => {
      window.editRecipeForSize(sizeId);
    }, 100); // Small delay to let modal open and render
  } else {
    window.switchTab('recipe');
  }
}

// Removing legacy modal setup code (setupRecipeSizeSelector) as it is unused now.
function setupRecipeSizeSelector(product) { }


function setupRecipeSizeSelector(product) {
  const container = document.getElementById('recipe-size-selector-container');
  // We need to inject this container into HTML first or assume it exists.
  // I'll add it to products.html via separate edit.

  if (!container) return; // Fail safe

  container.innerHTML = '';

  if (product.hasSizes) {
    container.style.display = 'block';
    const label = document.createElement('span');
    label.textContent = "Select Size to Edit: ";
    container.appendChild(label);

    product.sizes.forEach(size => {
      const btn = document.createElement('button');
      btn.className = 'btn btn-sm btn-secondary';
      btn.style.marginRight = '5px';
      btn.textContent = size.name;
      btn.onclick = () => loadRecipeForSize(size.id);
      container.appendChild(btn);
    });

    // Clear table initially until size picked
    document.getElementById('recipeTableBody').innerHTML = '<tr><td colspan="7">Please select a size above</td></tr>';
    currentRecipe = [];
  } else {
    container.style.display = 'none';
    loadRecipeForSize(null); // Load root recipe
  }
}

function loadRecipeForSize(sizeId) {
  const product = window.DB.getPart(currentRecipeProductId);
  currentRecipeSizeId = sizeId;

  // Highlight active button? (skip for now)

  if (product.hasSizes && sizeId) {
    const size = product.sizes.find(s => s.id == sizeId);
    currentRecipe = size ? (size.recipe || []) : [];
  } else {
    currentRecipe = product.recipe || [];
  }

  renderRecipeTable();
}

function saveRecipe() {
  if (!currentRecipeProductId) return;
  const product = window.DB.getPart(currentRecipeProductId);
  if (!product) return;

  const total = parseFloat(document.getElementById('recipeTotalCost').textContent) || 0;

  if (product.hasSizes && currentRecipeSizeId) {
    const sizeIndex = product.sizes.findIndex(s => s.id == currentRecipeSizeId);
    if (sizeIndex >= 0) {
      product.sizes[sizeIndex].recipe = currentRecipe;
      product.sizes[sizeIndex].cost = total; // Update Size Cost
    }
    // Update Main Product Cost range (optional)
    product.cost = Math.min(...product.sizes.map(s => s.cost));
  } else {
    product.recipe = currentRecipe;
    product.cost = total; // Update Product Cost
  }

  window.DB.savePart(product);
  alert('Recipe saved and Cost updated!');
  closeRecipeModal();
  loadProducts();
}

function loadRecipeIngredientsDropdown() {
  const ingredients = window.DB.getIngredients();
  const select = document.getElementById('recipe-ingredient');
  select.innerHTML = '<option value="">-- Select Ingredient --</option>';

  ingredients.forEach(ing => {
    const opt = document.createElement('option');
    opt.value = ing.id;
    opt.textContent = `${ing.name} (${ing.unit}) - ${parseFloat(ing.cost).toFixed(2)}`;
    select.appendChild(opt);
  });
}

function addIngredientToRecipe() {
  const ingredientId = document.getElementById('recipe-ingredient').value;
  const qty = parseFloat(document.getElementById('recipe-qty').value);
  const wasteVal = parseFloat(document.getElementById('recipe-waste').value) || 0;
  const wasteType = document.getElementById('recipe-waste-type').value;

  if (!ingredientId || isNaN(qty) || qty <= 0) return alert('Please select ingredient and valid quantity');

  const ingredient = window.DB.getIngredient(ingredientId);

  // Add to list
  currentRecipe.push({
    ingredientId: parseInt(ingredientId),
    name: ingredient.name,
    unit: ingredient.unit,
    qty: qty,
    wasteValue: wasteVal,
    wasteType: wasteType, // 'percent' or 'fixed'
    costPerUnit: ingredient.cost
  });

  renderRecipeTable();

  // Reset inputs
  document.getElementById('recipe-qty').value = '';
  document.getElementById('recipe-waste').value = 0;
}

// Consolidated Recipe Render
window.renderSingleRecipeTable = function () {
  const tbody = document.getElementById('single-recipe-body');
  if (!tbody) return;

  tbody.innerHTML = '';
  let totalCost = 0;

  currentSingleRecipe.forEach((item, index) => {
    const ingredient = window.DB.getIngredient(item.ingredientId);
    const unitCost = parseFloat(item.costPerUnit || (ingredient ? ingredient.cost : 0));
    const netQty = parseFloat(item.qty);
    const wasteVal = parseFloat(item.wasteValue || 0);
    const wasteType = item.wasteType || 'percent';

    let grossQty = 0;
    if (wasteType === 'fixed') {
      grossQty = netQty + wasteVal;
    } else {
      const yieldPercent = (100 - wasteVal) / 100;
      grossQty = (yieldPercent > 0) ? netQty / yieldPercent : netQty;
    }

    // Conversion? costPerUnit is usually per Base Unit.
    // If item.qty is in Usage Unit (e.g. g), we need to normalize costs.
    // In `addIngredient...` we stored `factor`.
    // Let's assume `item.costPerUnit` is accurate for `item.unit`?
    // In `addIngredientToSingleRecipe`, we calculated costPerUnit = baseCost * conversionFactor. 
    // So `lineCost = grossQty * costPerUnit` is correct IF grossQty is in Usage Units. 
    // Yes.

    const lineCost = grossQty * unitCost;
    totalCost += lineCost;

    const row = document.createElement('tr');
    row.innerHTML = `
            <td>${item.name}</td>
            <td>${netQty}</td>
            <td>${item.unit}</td>
            <td>${wasteType === 'fixed' ? wasteVal : wasteVal + '%'}</td>
            <td>${lineCost.toFixed(2)}</td>
            <td><button type="button" class="btn btn-sm btn-danger" onclick="removeSingleRecipeItem(${index})">x</button></td>
        `;
    tbody.appendChild(row);
  });

  const displayTotal = document.getElementById('display-total-cost');
  if (displayTotal) displayTotal.textContent = totalCost.toFixed(2);

  const hiddenCost = document.getElementById('product-cost');
  if (hiddenCost) hiddenCost.value = totalCost.toFixed(2);

  // Update Size Cost in Memory
  if (currentEditingSizeId) {
    const s = currentSizes.find(sz => sz.id === currentEditingSizeId);
    if (s) s.cost = totalCost;
  }
}

window.removeSingleRecipeItem = function (index) {
  currentSingleRecipe.splice(index, 1);
  renderSingleRecipeTable();
}

function saveRecipe() {
  if (!currentRecipeProductId) return;

  const product = window.DB.getPart(currentRecipeProductId);
  if (product) {
    product.recipe = currentRecipe;

    // specific logic: Update Product Cost Field based on Recipe Total?
    const total = parseFloat(document.getElementById('recipeTotalCost').textContent);
    product.cost = total; // Update the "Cost" field automatically

    window.DB.savePart(product);
    alert('Recipe saved and Cost updated!');
    closeRecipeModal();
    loadProducts(); // Refresh list
  }
}

function closeRecipeModal() {
  document.getElementById('recipeModal').style.display = 'none';
}

// Expose
window.openRecipe = openRecipe;
window.closeRecipeModal = closeRecipeModal;
// window.addIngredientToRecipe and removeRecipeItem were deleted. 
// We keep openRecipe because it is still called by the "Recipe" button in the table (legacy).
// Helpers for Categories which were missing or overwritten
function loadCategories() {
  const categories = JSON.parse(localStorage.getItem("categories") || "[]");
  const select = document.getElementById("product-category");
  const list = document.getElementById("category-list");

  if (!select || !list) return;

  select.innerHTML = '<option value="">-- Select --</option>';
  list.innerHTML = "";

  categories.forEach(cat => {
    const opt = document.createElement("option");
    opt.value = cat;
    opt.textContent = cat;
    select.appendChild(opt);

    const li = document.createElement("li");
    li.textContent = cat;
    list.appendChild(li);
  });
}

function handleAddCategory(e) {
  e.preventDefault();
  const input = document.getElementById("new-category");
  const cat = input.value.trim();
  if (!cat) return;

  const categories = JSON.parse(localStorage.getItem("categories") || "[]");
  if (!categories.includes(cat)) {
    categories.push(cat);
    localStorage.setItem("categories", JSON.stringify(categories));
    loadCategories();
  }
  input.value = "";
}

window.editProduct = (id) => {
  const product = window.DB.getPart(id);
  if (!product) return;

  document.getElementById("product-id").value = product.id;
  document.getElementById("product-code").value = product.partNumber || "";
  document.getElementById("product-name").value = product.name;
  document.getElementById("product-category").value = product.category || "";
  document.getElementById("product-price").value = product.price;
  document.getElementById("product-cost").value = product.cost || 0;
  document.getElementById("product-image").value = product.image || "";
  document.getElementById("product-stock").value = product.stock || 0;

  // Load Add-ons state
  const allowAllCheck = document.getElementById('allow-all-addons');
  if (allowAllCheck) {
    allowAllCheck.checked = !!product.allowAllAddons;
  }

  allowedAddons = product.allowedAddons || [];

  toggleAddonsContainer();
  loadAddonsDropdown();
  renderAllowedAddons();

  document.getElementById('productModalTitle').textContent = 'Edit Product';
  document.getElementById('productModal').style.display = 'flex';
};
window.deleteProduct = (id) => {
  if (confirm('Delete?')) {
    window.DB.deletePart(id);
    loadProducts();
  }
};

function closeProductModal() {
  document.getElementById('productModal').style.display = 'none';
}
window.closeProductModal = closeProductModal;

// --- Recipe Tab Logic Enhancements ---

function renderRecipeSizeButtons() {
  const container = document.getElementById('recipe-size-selector-container');
  if (!container) return;
  container.innerHTML = '<strong>Select Size: </strong>';

  currentSizes.forEach(s => {
    const btn = document.createElement('button');
    btn.textContent = s.name;
    btn.className = `btn btn-sm ${(currentEditingSizeId == s.id) ? 'btn-primary' : 'btn-secondary'}`;
    btn.style.margin = '0 5px';
    btn.onclick = (e) => {
      e.preventDefault(); // prevent form submit
      currentEditingSizeId = s.id;
      // Load recipe for this size
      currentSingleRecipe = s.recipe || [];
      renderRecipeSizeButtons(); // update active class
      renderSingleRecipeTable(); // render table
    };
    container.appendChild(btn);
  });
}

// Updating renderSingleRecipeTable to update Total Cost Display


// Unit Conversion Logic
const unitConversions = {
  'kg': { 'kg': 1, 'g': 0.001 },
  'g': { 'kg': 1000, 'g': 1 },
  'l': { 'l': 1, 'ml': 0.001 },
  'ml': { 'l': 1000, 'ml': 1 },
  'pcs': { 'pcs': 1 }
};

function getCompatibleUnits(baseUnit) {
  if (baseUnit === 'kg' || baseUnit === 'g') return ['kg', 'g'];
  if (baseUnit === 'l' || baseUnit === 'ml') return ['l', 'ml'];
  return [baseUnit];
}

function updateRecipeUnitOptions() {
  const ingId = document.getElementById('single-recipe-ingredient').value;
  const unitSelect = document.getElementById('single-recipe-unit');
  if (!ingId || !unitSelect) return;

  const ingredient = window.DB.getIngredient(ingId);
  if (!ingredient) return;

  const units = getCompatibleUnits(ingredient.unit);
  unitSelect.innerHTML = '';
  units.forEach(u => {
    const opt = document.createElement('option');
    opt.value = u;
    opt.textContent = u;
    if (u === ingredient.unit) opt.selected = true; // Default to base
    unitSelect.appendChild(opt);
  });
}


function loadSingleRecipeIngredientsDropdown() {
  const ingredients = window.DB.getIngredients();
  const select = document.getElementById('single-recipe-ingredient');
  if (!select) return;
  select.innerHTML = '<option value="">-- Select --</option>';

  ingredients.forEach(ing => {
    const opt = document.createElement('option');
    opt.value = ing.id;
    opt.textContent = `${ing.name} (${ing.unit}) - ${parseFloat(ing.cost).toFixed(2)}`;
    select.appendChild(opt);
  });

  select.onchange = updateRecipeUnitOptions;
}

window.addIngredientToSingleRecipe = function () {
  const ingredientId = document.getElementById('single-recipe-ingredient').value;
  const qty = parseFloat(document.getElementById('single-recipe-qty').value);
  const usageUnit = document.getElementById('single-recipe-unit').value;
  const wasteVal = parseFloat(document.getElementById('single-recipe-waste').value) || 0;
  const wasteType = document.getElementById('single-recipe-waste-type').value;

  if (!ingredientId || isNaN(qty) || qty <= 0 || !usageUnit) return alert('Select ingredient, unit, and valid quantity');

  const ingredient = window.DB.getIngredient(ingredientId);
  const baseUnit = ingredient.unit;

  // Calculate Factor: Usage Unit -> Base Unit
  // e.g. Usage: g, Base: kg. Factor = 0.001
  let conversionFactor = 1;
  if (unitConversions[baseUnit] && unitConversions[baseUnit][usageUnit] !== undefined) {
    // Wait, structure above is Base -> Targets? No.
    // If Base is kg. Usage is g. Value is 0.001. So 500g * 0.001 = 0.5kg. Correct.
    conversionFactor = unitConversions[baseUnit][usageUnit];
  } else if (unitConversions[usageUnit] && unitConversions[usageUnit][baseUnit]) {
    // If Usage is kg, Base is g. Factor is 1000.
    conversionFactor = unitConversions[usageUnit][baseUnit];
    // Wait, logic check.
    // If I have 1kg (Usage), and Base is g. I need 1000g.
    // My table: 'kg': {'g': 0.001} means 1g = 0.001kg.
    // So if usage is 'kg' and base is 'g'. I need 'kg' -> 'g'.
    // 1 kg = 1000 g.
    // Table needs to be bi-directional or smarter.
  }

  // Revised Conversion Logic
  // We want to convert UsageQty to BaseQty.
  // usageQty * factor = baseQty.

  if (baseUnit === 'kg' && usageUnit === 'g') conversionFactor = 0.001;
  else if (baseUnit === 'g' && usageUnit === 'kg') conversionFactor = 1000;
  else if (baseUnit === 'l' && usageUnit === 'ml') conversionFactor = 0.001;
  else if (baseUnit === 'ml' && usageUnit === 'l') conversionFactor = 1000;
  else conversionFactor = 1;

  // Cost per Usage Unit
  // Cost is per Base Unit.
  // Cost per Usage Unit = Base Cost * Conversion Factor?
  // e.g. Base Cost $10/kg. Usage Unit g. Factor 0.001. Cost/g = $10 * 0.001 = $0.01. Correct.
  const costPerUsageUnit = ingredient.cost * conversionFactor;

  currentSingleRecipe.push({
    ingredientId: parseInt(ingredientId),
    name: ingredient.name,
    unit: usageUnit, // Store the Usage Unit
    baseUnit: baseUnit,
    qty: qty,
    conversionFactor: conversionFactor,
    wasteValue: wasteVal,
    wasteType: wasteType,
    costPerUnit: costPerUsageUnit // Visual Cost per Usage Unit
  });

  renderSingleRecipeTable();
  document.getElementById('single-recipe-qty').value = '';
  document.getElementById('single-recipe-waste').value = 0;
};

function renderSingleRecipeTable() {
  const tbody = document.getElementById('single-recipe-body');
  if (!tbody) return;
  tbody.innerHTML = '';
  let totalCost = 0;

  currentSingleRecipe.forEach((item, index) => {
    const ingredient = window.DB.getIngredient(item.ingredientId);
    const unitCost = ingredient ? parseFloat(ingredient.cost) : 0;
    const netQty = parseFloat(item.qty);
    const wasteVal = parseFloat(item.wasteValue || 0);
    const wasteType = item.wasteType || 'percent';

    let grossQty = 0;
    if (wasteType === 'fixed') {
      grossQty = netQty + wasteVal;
    } else {
      if (wasteVal >= 100) grossQty = netQty;
      else {
        const yieldPercent = (100 - wasteVal) / 100;
        grossQty = netQty / yieldPercent;
      }
    }

    const lineCost = grossQty * unitCost;
    totalCost += lineCost;

    const row = document.createElement('tr');
    let wasteDisplay = wasteType === 'fixed' ? `${wasteVal} (Fix)` : `${wasteVal}%`;

    row.innerHTML = `
      <td>${item.name}</td>
      <td>${netQty}</td>
      <td>${wasteDisplay}</td>
      <td>${grossQty.toFixed(3)}</td>
      <td>${lineCost.toFixed(2)}</td>
      <td><button type="button" class="btn btn-sm btn-danger" onclick="removeSingleRecipeItem(${index})" style="padding:0 5px;">x</button></td>
    `;
    tbody.appendChild(row);
  });

  const totalEl = document.getElementById('single-recipe-total');
  if (totalEl) totalEl.textContent = totalCost.toFixed(2);

  const costInput = document.getElementById('product-cost');
  if (costInput) costInput.value = totalCost.toFixed(2);
}

window.removeSingleRecipeItem = function (index) {
  currentSingleRecipe.splice(index, 1);
  renderSingleRecipeTable();
};

window.openRecipeForSizeInModal = function (index) {
  const size = currentSizes[index];
  currentRecipe = size.recipe || [];
  currentRecipeProductId = null;

  document.getElementById('recipeItemName').textContent = "Size: " + size.name;
  document.getElementById('recipeModal').style.display = 'flex';
  document.getElementById('recipeModal').dataset.mode = 'memory';
  document.getElementById('recipeModal').dataset.sizeIndex = index;

  const sel = document.getElementById('recipe-size-selector-container');
  if (sel) sel.style.display = 'none';

  renderRecipeTable();
  loadRecipeIngredientsDropdown();
};

const originalSaveRecipe = window.saveRecipe;
window.saveRecipe = function () {
  const modal = document.getElementById('recipeModal');
  if (modal.dataset.mode === 'memory') {
    const index = parseInt(modal.dataset.sizeIndex);
    if (currentSizes[index]) {
      currentSizes[index].recipe = [...currentRecipe];
      const total = parseFloat(document.getElementById('recipeTotalCost').textContent) || 0;
      currentSizes[index].cost = total;
      renderSizesTable();
      closeRecipeModal();
    }
  } else {
    originalSaveRecipe();
  }
};
